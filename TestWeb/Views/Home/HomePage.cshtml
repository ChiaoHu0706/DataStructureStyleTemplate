<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>什麼是演算法？</title>
  <style>
        .subheading {
            color: #3931af;
            font-size: 20px;
        }
        .card-image{
            max-width:960px;
            max-height:700px;
        }
         /* 在小尺寸螢幕上，讓圖片在上，文字在下 */
   
  </style>
</head>
<main>
    <div class="container mt-5">
        <h1 class="text-center">演算法(Algorithms)的定義</h1>
        <div class="text-justify">
            <p>根據韋氏字典(Merriam-Webster Dictionary)對演算法的定義:「在有限步驟內，解決數學問題的程序」。</p>
            <p>在計算機科學領域中，演算法是「一種解決問題的策略與法則，在有限的步驟內，解決特定的問題」。</p>
        </div>
        <h2 class="mt-5">演算法的關鍵特徵:</h2>
        <ul>
            <li><strong>輸入(Input):</strong> 演算法接受零個或多個輸入，這些輸入可能是來自外部環境或者是先前計算的結果。</li>
            <li><strong>輸出(Output):</strong> 對於給定的輸入，演算法應該產生一個或多個輸出，這些輸出與問題的要求相關。</li>
            <li><strong>清晰性(Clearness):</strong> 演算法的步驟應該清晰而明確，沒有歧義。每個步驟都應該以精確的方式定義，以便理解和實現。</li>
            <li><strong>有限性(Finiteness):</strong> 演算法應該在有限步驟內終止，無論輸入的大小如何。換句話說，演算法不應該進入無窮循環或無窮遞迴。</li>
            <li><strong>有效性(Effectiveness):</strong> 演算法的每個步驟都應該是可以實際執行的，並且在有限時間內完成。此外，演算法的效率應該足夠高，以便在合理的時間內處理大量的輸入。</li>
        </ul>
        <div class="text-justify">
            <p>這些特性確保了演算法能夠正確地解決問題，並且在實際應用中具有可靠性和可行性。</p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <img class="card-image" style="width:100%;" src="@Url.Content("../Image/CatHanoiTower.png")">
        </div>
        <div class="col-md-6 HomepageGrid">
            <h2 class="card-title" style="text-align:center;">河內塔遊戲</h2>
            <p class="card-body">
                <p>河內塔是一個經典的益智遊戲，它能夠挑戰你的邏輯思維和問題解決能力。這個遊戲的目標是將所有的圓盤從一根柱子移動到另一根柱子，但是在移動過程中你必須遵從以下規則：</p>
                <ol>
                <li>一次只能移動一個圓盤。</li>
                <li>每個圓盤只能放在比它大的圓盤上面。</li>
            </ol>
            </p>
            <button type="button" class="btn btn-outline-primary">開始遊玩</button>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <img class="card-image" style="width:100%;" src="@Url.Content("../Image/nekopoke.png")">
        </div>
        <div class="col-md-6 HomepageGrid">
            <h2 class="card-title" style="text-align:center;">排序</h2>
            <p class="card-body">
                相信大家都有玩過撲克牌，那有沒有想過，假設今天將撲克牌打亂，你們會用甚麼樣的方式將其重新排序好呢？
            </p>
            <p class="card-body">
                接著思考，會用多少的時間(步驟)完成?<br /><br />
                排序演算法相信學過程式設計的人100%都會遇到，至於你知不知道排序法到底要怎麼跑呢，讓我們來模擬一下吧。<br />
                那我們本章會學習到的排序法包刮：<br />
                <ol>
                    <li>氣泡排序法(Bubble Sort)</li>
                    <li>選擇排序法(Selection Sort)</li>
                    <li>快速排序法(Quick Sort)</li>
                    <li>堆積排序法(Heap Sort)</li>
                </ol>
            </p>
            <button type="button" class="btn btn-outline-primary">開始遊玩</button>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <img class="card-image" style="width:100%;" src="@Url.Content("../Image/CatUseGlass.jpg")">
        </div>
        <div class="col-md-6 HomepageGrid">
            <h2 class="card-title" style="text-align:center;">搜尋</h2>
            <p class="card-body">
                搜尋演算法是一種用於在資料集合中尋找特定項目或滿足特定條件的技術。這些演算法通常根據搜尋範圍、效率要求和資料結構的特性進行分類。
                本章會學期到的搜尋演算法如下：
            </p>
            <ol>
                <li>乖寶寶式的循序搜尋法</li>
                <li>
                    厲害的二元搜尋法與二元搜尋樹
                    <ol type="I">
                        <li>⊶ 二元樹(Binary Tree)</li>
                        <li>⊶ 二元搜尋樹(Binary Search Tree)</li>
                        <li>⊶ 高度平衡二元樹 (AVL樹)</li>
                    </ol>
                </li>
            </ol>
            <button type="button" class="btn btn-outline-primary">開始遊玩</button>
        </div>
    </div>
    <div class="card-group">
        <div class="card">
            <img class="card-img-top" src="@Url.Content("../Image/nekobox3.jpg")" alt="Card image cap">
            <div class="card-body">
                <h5 class="card-title">陣列/鏈結串列</h5>
                <p class="card-text">
                    陣列和鏈結串列是在程式設計中常見的資料結構。陣列是一種連續的記憶體區塊，鏈結串列是一種由節點組成的結構，我們可以用遊戲來讓大家了解。
                </p>
            </div>
            <div class="card-footer">
                <div style="text-align:center;"><button type="button" class="btn btn-outline-primary">開始遊玩</button></div>
            </div>
        </div>
        <div class="card">
            <img class="card-img-top" src="@Url.Content("../Image/nekopintu.jpg")" alt="Card image cap">
            <div class="card-body">
                <h5 class="card-title">圖形</h5>
                <p class="card-text">
                    在圖形中我們可以學習到：<br />
                    1.廣度優先走訪(BFS)<br/>
                    2.深度優先走訪(DFS)<br />
                    3.Kruskal 演算法<br />
                    4.Prim 演算法<br />
                    5.Dijkstra 最短路徑演算法<br />
                </p>
            </div>
            <div class="card-footer">
                <div style="text-align:center;"><button type="button" class="btn btn-outline-primary">開始遊玩</button></div>
            </div>
        </div>

        <div class="card">
            <img class="card-img-top" src="@Url.Content("../Image/nekotree.jpg")" alt="Card image cap">
            <div class="card-body">
                <h5 class="card-title">樹狀結構</h5>
                <p class="card-text">既然我們前面學過了二元樹了，那我們就直接來開始遊戲吧，來讓自己試試看自己學的到底是不是對的。</p>
            </div>
            <div class="card-footer">
                <div style="text-align:center;"><button type="button" class="btn btn-outline-primary">開始遊玩</button></div>
            </div>
        </div>
    </div>
</main>
